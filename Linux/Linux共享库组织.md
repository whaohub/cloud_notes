# Linux 共享库组织

## 共享库版本

## 二进制的兼容性

所谓“二进制兼容性”指的就是在升级（也可能是 bug fix）库文件的时候，不 必重新编译使用了这个库的可执行文件或其他库文件，程序的功能不被破坏。

如果以 shared library 方式提供函数库，那么头文件和库 文件不能轻易修改，否则容易破坏已有的二进制可执行文件，或者其他用到这个 shared library 的 library。

如何判断一个改动是不是二进制兼容，主要就是看头文件暴露的这份“使用说明”能否与新版本的动态库的实际使用方法兼容。因为新的库 必然有新的头文件，但是现有的二进制可执行文件还是按旧的头文件来调用动态库。

### 共享库的兼容性

由于共享库的灵活性，使得程序本身和所依赖的共享库可以分别独立开发和更新，共享库的更新可以分为俩类:

* 兼容更新
  所有的更新只是在原有的共享库基础上添加一些内容，所有原有的接口都保持不变。
* 不兼容更新
  共享库更新改变了原有的接口，使用该共享库原有接口的程序可能不能运行或运行不正常。
  这里的接口是二进制接口(ABI)

导致C语言的共享库ABI改变的行为主要有如下4个:

* 导出函数的行为发生变化，也就是说调用这个函数以后发生的结果与以前不一样，不再满足旧版本规定的函数行为准则。

* 导出函数被删除

* 导出数据的结构发生变化，比如共享库定义的结构体变量结构发生变化:结构成员删除，顺序改变或其他引起结构体内存布局变化的行为(不过通常来讲，往结构体尾部添加成员不会导致不兼容，当然这个结构体必须是共享库内部分配的，如果是外部分配的，在分配该结构体时必须考虑成员添加的情况)。

* 导出函数的接口发生变化，如函数返回值，参数被更改。

如果保持上述4种情况不发生，那么绝大部分情况下，C语言的共享库将会保持ABI兼容。这仅仅是绝大部分情况，要破坏一个共享库的ABI十分容易，要保持ABI兼容确十分困难。很多因素会导致ABI不兼容，比如不同版本的编译器，操作系统和硬件平台。使用不同版本的编译器或系统库可能会导致结构体的成员对齐方式不一致,从而导致ABI的变化.这种ABI不兼容导致的问题可能非常微妙,表面看可能无关紧要,但是一旦发生故障,相关的bug非常难以定位,这也是共享库很大的一个问题.

对于C++来说,ABI问题就更为严重了.由于C++非常复杂,他支持诸如模板等一些高级特性,这些特性对于ABI兼容来说简直是灾难.因为C++标准对于C++的ABI没有作出规定,所以不同编译器甚至同一编译器的不同版本对于C++的一些特性的实现都有各自的方案,而且相互不兼容,比如虚函数表,模板实例化,多重继承等.对于linux来说如果你要开发一个导出接口为C++的共享库,要注意以下事项,以防止ABI不兼容(完全遵循以下准则还是不能保证ABI完全兼容):

- 不要在接口类中使用虚函数,万不得已要使用虚函数时,不要随意删除,添加或在子类中添加新的实现函数,这样会导致类的虚函数表结构发生变化.

- 不要改变类中任何成员变量的位置和类型

- 不要删除非内嵌的public或protected成员函数

- 不要将非内嵌的成员函数改变成内嵌成员函数

- 不要改变成员函数的访问权限

- 不要再接口中使用模板

- 最重要的是,不要改变接口的任何部分或干脆不要使用C++作为共享库接口!

## linux 查看正在被进程使用的so

- 运行进程之前，可以使用ldd查看进程依赖的动态库ldd 可执行程序

- 进程运行起来之后， 使用pmap查看加载了哪些动态库，和动态库的映射位置
  pmap -x 进程号

- 如果想知道打开的是哪个动态库，想知道动态库的路径，
  
  ```shell
  lsof： lsof 进程号
  pmap -p 进程号
  ```

## 加载动态库

Tags:
  Linking, Loaders, 程序员的自我修养
