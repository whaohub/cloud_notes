# Template

## 函数模板

函数模板就是提供一组不同数据类型的函数行为，即是一组函数

## 定义模板

模板参数必须按照如下语法声明：

> ​    template< 由逗号分割的模板参数>

```c++
template<typename T>
const T& min(const T& a,const T& b)
{
    return a < b ? b : a; 
}

template<typename T>
void print(const T& var)
{
    std::cout<<var<<std::endl;
}
```

## 使用模板

```cpp
int main()
{
    print(::min(10, 20));  //20
    print(::min(11.1,12.1)); // 12.1
    print(::min(std::string("ab"),std::string("abc"))); //abc

    return 0;
}
```

注意调用时使用了作用域限制符::,这样程序将会在全局作用域中查找max()模板。否则的话，在某些情况下标准库中的 std::max()模板将会被调用，或者有时候不太容易确定具体哪一个模板会被调用。

在编译阶段，模板并不是被编译成一个可以支持多种类型的实体。而是对每一个用于该模板
的类型都会产生一个独立的实体。因此在本例中，max()会被编译出三个实体，因为它被用
于三种类型。

用具体类型取代模板参数类型的过程叫模板实例化

## 两阶段编译检查（Two-PhaseTranslation）

在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面：

- 语法检查。比如少了分号。
- 使用了未定义的不依赖于模板参数的名称（类型名，函数名，......）。
- 未使用模板参数的 static assertions。

在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖
于类型参数的部分。

## 类型推断中的类型转换

在类型推断的时候自动的类型转换是受限制的：

- 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的
  两个参数，它们实参的类型必须完全一样。
- 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const
  和 volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相
  应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay）
  后必须一样。

```c++
print(::min(10,10.11))  //参数li
```

## 函数模板的重载

一个非模板函数可以与其同名的模板函数同名，并且这个同名的模板函数可以实例化与模板函数同类型的函数，在其他所有元素相同情况下，模板解析过程会优先选择非模板函数，而不是模板实例化出的函数

```cpp
//overload
int max(int a, int b)  
{   
    std::cout<<"non-template max"<<std::endl;
    return a < b ? b : a;
}

void CallOverload()
{
    ::max(10, 20); // int non-template
    ::max<>(10, 20); //显示指定模板调用

    ::max(10.2, 11.2);
    ::max('a', 'b');  
    ::max('a', 20);
}
```
